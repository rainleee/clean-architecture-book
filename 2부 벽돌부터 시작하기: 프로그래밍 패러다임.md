# 3장 패러다임 개요

# 4장 구조적 프로그래밍

# 5장 객체 지향 프로그래밍

# 6장 함수형 프로그래밍

- 함수형 프로그래밍 패러다임에서 핵심이 되는 기반은 람다(lambda) 계산법으로 알론조 처지가 1930년대 발명했다.

## 예제 - 정수를 제곱하기
![java로 정수를 제곱하는 코드](https://user-images.githubusercontent.com/50471668/222942205-2d890c34-9dba-40af-ad5b-36ecede28e68.png)

                                            java로 정수를 제곱하는 코드

![clojure로 정수를 제곱하는 코드](https://user-images.githubusercontent.com/50471668/222942231-3800c260-9e24-4580-8e12-d9efc02ba89f.png)

                                           clojure로 정수를 제곱하는 코드

- 위 예제에서 클로저와 자바 프로그램 사이의 극단적인 차이를 짚어보자면 자바는 가변 변수(mutale variable)를 사용하는데, 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다.
- 클로저에서는 이러한 가변 변수가 전혀 없다. 클로저에서는 x와 같은 변수가 한 번 초기화되면 절대로 변하지 않는다. **함수형 언어에서 변수는 변경되지 않는다.**

## 불변성과 아키텍처

- 아키텍트는 왜 변수의 가변성을 염려하는가? 답은 단순하다. 경합(race)조건, 교착상태(deadlock), 동시 업데이트(concurrent update) 문제가 모두 가변 변수로 인해 발생하기 떄문이다. 만약 어떤 변수도 갱신되지 않는다면 경합 조건이나 동시 업데이트 문제가 일어나지 않는다.
- **다시 말해 우리가 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.**
- 아키텍트라면 동시성(concurrency) 문제에 지대한 관심을 가져야만 한다. 우리는 스레드와 프로세스가 여러 개인 상황에서도 설계한 시스템이 여전히 강건하기를 바란다. 그렇다면 이제 불변성이 정말로 실현 가능한지를 스스로에게 반드시 물어야 한다. 이 질문에 대한 대답은 대체로 긍정적이지만, 자원이 무한대가 아니라면 대답은 조금 미묘하다. 이제 어떤 타협이 필요한지 살펴보자.

## 가변성의 분리

- 불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다. **불변 컴포넌트에서는 순수하게  함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다. 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.**
![3](https://user-images.githubusercontent.com/50471668/222942261-4d655457-a9bf-42b6-b7b8-0dc73289b553.png)


- 상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리(transactional memory)와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.
- **애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다는 것이다.** 그리고 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야 한다. **현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 뺴내야 한다.**

## 이벤트 소싱

- 저장 공간과 처리 능력의 한 우리의 시야에서 급격히 사라지고 있다. 더 많은 메모리를 확보할수록, 기계가 더 빨라질수록, 필요한 가변 상태는 더 적어진다.
- 간단한 예로, 고객의 계좌 잔고를 관리하는 은행 애플리케이션을 생각해보자. 이 애플리케이션에서는 입금 트랜잭션과 출금 트랜잭션이 실행되면 잔고를 변경해야 한다. **이제 계좌 잔고를 변경하는 대신 트래잭션 자체를 저장한다고 상상해보자. 이 전략에서는 가변 변수가 하나도 필요없다.**
- 이러한 접근법은 터무니없다. 시간이 지날수록 트랜잭션 수는 끝없이 증가하고, 잔고 계산에 필요한 컴퓨팅 자원은 걷잡을 수 없이 커진다. 따라서 이 전략이 영원히 실현 가능하려면 무한한 저장 공간과 무한한 처리 능력이 필요하다.
- 하지만 이 전략이 영원히 동작하도록 만들 필요는 없다. 아마도 애플리케이션의 수명주기 동안만 문제없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분할 것이다.
- **이벤트 소싱(event sourcing)에 깔려 있는 기본 발상이 바로 이것이다. 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지만 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.**
- 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실이다. 결과적으로 애플리케이션은 **CRUD가 아니라 그저 CR만 수행**한다. 또한 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.
- 이 이야기가 여전히 터무니없게 들린다면, 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다는 사실을 떠올려 보면 도움이 될 것이다.

## 결론

- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
- 각 패러다임은 모두 우리에게서 무언가를 앗아갔다. 각 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시킨다. **어떠한 패러다임도 우리의 권한이나 능력에 무언가를 보태지 않는다. 지난 반세기 동안 우리가 배운 것은 해서는 안 되는 것에 대해서다.**
- 소프트웨어는 급격히 발전하는 기술이 아니라는 진실과 마주하게 된다. 1946년에 최초의 코드를 작성할때 사용한 소프트웨어 규칙과 지금의 소프트웨어 규칙은 조금도 다르지 않다.
- **소프트웨어, 컴퓨터 프로그램은 순차(sequence), 분기(selection), 반복(iteration), 참조(indirection)로 구성된다. 그 이상도 이하도 아니다.**
